
Q1. Query all columns for all American cities in the CITY table with populations larger than 100000.
The CountryCode for America is USA.

ans== 
select * FROM CITY WHERE Population > 100000 and CountryCode = 'USA';



The CITY table is described as follows:
Q2. Query the NAME field for all American cities in the CITY table with populations larger than 120000.
The CountryCode for America is USA.
ans==
SELECT NAME
FROM CITY
WHERE Population > 120000 AND CountryCode = 'USA';

The CITY table is described as follows:
Q3. Query all columns (attributes) for every row in the CITY table.
ans =  SELECT *
FROM CITY;


The CITY table is described as follows:
Q4. Query all columns for a city in CITY with the ID 1661.
ans = select *from city where id = 1611;


The CITY table is described as follows:
Q5. Query all attributes of every Japanese city in the CITY table. The COUNTRYCODE for Japan is
JPN.
ans = SELECT *
FROM CITY
WHERE Country_Code = 'JPN';


The CITY table is described as follows:
Q6. Query the names of all the Japanese cities in the CITY table. The COUNTRYCODE for Japan is
JPN.
ans = select name
FROM CITY
WHERE Country_Code = 'JPN';


(The CITY table is described as follows:
station-table:https://docs.google.com/spreadsheets/d/1sHPhE7walQD5mL7ppFNqybyoOJY3E51N0
cWYzhp2UH4/edit?usp=sharing)


Q7. Query a list of CITY and STATE from the STATION table.
The STATION table is described as follows:
where LAT_N is the northern latitude and LONG_W is the western longitude.

ans = SELECT CITY, STATE, LAT_N, LONG_W FROM STATION


Q8. Query a list of CITY names from STATION for cities that have an even ID number. Print the results
in any order, but exclude duplicates from the answer.
The STATION table is described as follows:
where LAT_N is the northern latitude and LONG_W is the western longitude
ans =SELECT DISTINCT CITY, STATE, LAT_N, LONG_W FROM STATION WHERE MOD(ID, 2) = 0;



Q9. Find the difference between the total number of CITY entries in the table and the number of
distinct CITY entries in the table.
The STATION table is described as follows:
where LAT_N is the northern latitude and LONG_W is the western longitude.
For example, if there are three records in the table with CITY values 'New York', 'New York', 'Bengalaru',
there are 2 different city names: 'New York' and 'Bengalaru'. The query returns , because total number
of records - number of unique city names = 3-2 =1

ans  = SELECT COUNT(*) - COUNT(DISTINCT CITY) AS difference FROM STATION;

Q10. Query the two cities in STATION with the shortest and longest CITY names, as well as their
respective lengths (i.e.: number of characters in the name). If there is more than one smallest or
largest city, choose the one that comes first when ordered alphabetically.
The STATION table is described as follows:
where LAT_N is the northern latitude and LONG_W is the western longitude.
Sample Input
For example, CITY has four entries: DEF, ABC, PQRS and WXY.
Sample Output
ABC 3
PQRS 4
Hint -
When ordered alphabetically, the CITY names are listed as ABC, DEF, PQRS, and WXY, with lengths
and. The longest name is PQRS, but there are options for shortest named city. Choose ABC, because
it comes first alphabetically.
Note
You can write two separate queries to get the desired output. It need not be a single query.
ans = SELECT CITY, LENGTH(CITY) as len
FROM STATION
ORDER BY len DESC, CITY ASC
LIMIT 1; 


Q11. Query the list of CITY names starting with vowels (i.e., a, e, i, o, or u) from STATION. Your result
cannot contain duplicates.
Input Format
The STATION table is described as follows:
where LAT_N is the northern latitude and LONG_W is the western longitude.
ans = SELECT DISTINCT CITY
FROM STATION
WHERE CITY REGEXP '^[aeiouAEIOU].*';

Q12. Query the list of CITY names ending with vowels (a, e, i, o, u) from STATION. Your result cannot
contain duplicates.
Input Format
The STATION table is described as follows:
where LAT_N is the northern latitude and LONG_W is the western longitude.
ans = SELECT DISTINCT CITY
FROM STATION
WHERE CITY LIKE '%a'
   OR CITY LIKE '%e'
   OR CITY LIKE '%i'
   OR CITY LIKE '%o'
   OR CITY LIKE '%u';


Q13. Query the list of CITY names from STATION that do not start with vowels. Your result cannot
contain duplicates.
Input Format
The STATION table is described as follows:
where LAT_N is the northern latitude and LONG_W is the western longitude.
ans==  SELECT DISTINCT CITY
FROM STATION
WHERE CITY NOT LIKE 'A%'
  AND CITY NOT LIKE 'E%'
  AND CITY NOT LIKE 'I%'
  AND CITY NOT LIKE 'O%'
  AND CITY NOT LIKE 'U%';




Q14. Query the list of CITY names from STATION that do not end with vowels. Your result cannot
contain duplicates.
Input Format
The STATION table is described as follows:
where LAT_N is the northern latitude and LONG_W is the western longitude.
ans == SELECT DISTINCT CITY
FROM STATION
WHERE CITY NOT LIKE '%a'
AND CITY NOT LIKE '%e'
AND CITY NOT LIKE '%i'
AND CITY NOT LIKE '%o'
AND CITY NOT LIKE '%u';


Q15. Query the list of CITY names from STATION that either do not start with vowels or do not end
with vowels. Your result cannot contain duplicates.
Input Format
The STATION table is described as follows:
where LAT_N is the northern latitude and LONG_W is the western longitude.
Q16. Query the list of CITY names from STATION that do not start with vowels and do not end with
vowels. Your result cannot contain duplicates.
Input Format
The STATION table is described as follows:
where LAT_N is the northern latitude and LONG_W is the western longitude.
ans = SELECT DISTINCT CITY
FROM STATION
WHERE CITY NOT LIKE 'A%' 
  AND CITY NOT LIKE 'E%'
  AND CITY NOT LIKE 'I%'
  AND CITY NOT LIKE 'O%'
  AND CITY NOT LIKE 'U%'
  AND CITY NOT LIKE '%a' 
  AND CITY NOT LIKE '%e' 
  AND CITY NOT LIKE '%i' 
  AND CITY NOT LIKE '%o' 
  AND CITY NOT LIKE '%u'
ORDER BY CITY;



Q17.
Table: Product
Column Name Type
product_id int
product_name varchar
unit_price int
product_id is the primary key of this table.
Each row of this table indicates the name and the price of each product.
Table: Sales
Column Name Type
seller_id int
product_id int
buyer_id int
sale_date date
quantity int
price int
This table has no primary key, it can have repeated rows.
product_id is a foreign key to the Product table.
Each row of this table contains some information about one sale.
Write an SQL query that reports the products that were only sold in the first quarter of 2019. That is,
between 2019-01-01 and 2019-03-31 inclusive.
Return the result table in any order.
The query result format is in the following example.
Input:
Product table:
product_id product_name unit_price
1 S8 1000
2 G4 800
3 iPhone 1400
Sales table:
seller_id product_id buyer_id sale_date quantity price
1 1 1 2019-01-21 2 2000
1 2 2 2019-02-17 1 800
2 2 3 2019-06-02 1 800
3 3 4 2019-05-13 2 2800
Output:
product_id product_name
1 S8
Explanation:
The product with id 1 was only sold in the spring of 2019.
The product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.
The product with id 3 was sold after spring 2019.
We return only product 1 as it is the product that was only sold in the spring of 2019.

ans ==SELECT p.product_id, p.product_name
FROM Product p
WHERE p.product_id NOT IN (
  SELECT s.product_id
  FROM Sales s
  WHERE s.sale_date >= '2019-04-01'
)
AND p.product_id IN (
  SELECT s.product_id
  FROM Sales s
  WHERE s.sale_date BETWEEN '2019-01-01' AND '2019-03-31'
)  




Q18.
Table: Views
Column Name Type
article_id int
author_id int
viewer_id int
view_date date
There is no primary key for this table, it may have duplicate rows.
Each row of this table indicates that some viewer viewed an article (written by some author) on some
date.
Note that equal author_id and viewer_id indicate the same person.
Write an SQL query to find all the authors that viewed at least one of their own articles.
Return the result table sorted by id in ascending order.
The query result format is in the following example.
Input:
Views table:
article_id author_id viewer_id view_date
1 3 5 2019-08-01
1 3 6 2019-08-02
2 7 7 2019-08-01
2 7 6 2019-08-02
4 7 1 2019-07-22
3 4 4 2019-07-21
3 4 4 2019-07-21
Output:
id
4
7
ans == ELECT DISTINCT author_id AS id
FROM Views
WHERE author_id = viewer_id
ORDER BY id ASC;


Q19.
Table: Delivery
Column Name Type
delivery_id int
customer_id int
order_date date
customer_pref_delivery_date date
delivery_id is the primary key of this table.
The table holds information about food delivery to customers that make orders at some date and
specify a preferred delivery date (on the same order date or after it).
If the customer's preferred delivery date is the same as the order date, then the order is called
immediately; otherwise, it is called scheduled.
Write an SQL query to find the percentage of immediate orders in the table, rounded to 2 decimal
places.
The query result format is in the following example.
Input:
Delivery table:
delivery_id customer_id order_date
customer_pref_
delivery_date
1 1 2019-08-01 2019-08-02
2 5 2019-08-02 2019-08-02
3 1 2019-08-11 2019-08-11
4 3 2019-08-24 2019-08-26
5 4 2019-08-21 2019-08-22
6 2 2019-08-11 2019-08-13
Output:
immediate_percentage
33.33
ans== SELECT ROUND(COUNT(CASE WHEN order_date = customer_pref_delivery_date THEN 1 END) * 100.0 / COUNT(*), 2) AS immediate_percentage
FROM Delivery;


Explanation: The orders with delivery id 2 and 3 are immediate while the others are scheduled.
Q20.
Table: Ads
Column Name Type
ad_id int
user_id int
action enum
(ad_id, user_id) is the primary key for this table.
Each row of this table contains the ID of an Ad, the ID of a user, and the action taken by this user
regarding this Ad.
The action column is an ENUM type of ('Clicked', 'Viewed', 'Ignored').
A company is running Ads and wants to calculate the performance of each Ad.
Performance of the Ad is measured using Click-Through Rate (CTR) where:
Write an SQL query to find the ctr of each Ad. Round ctr to two decimal points.
Return the result table ordered by ctr in descending order and by ad_id in ascending order in case of a
tie.
The query result format is in the following example.
Input:
Ads table:
ad_id user_id action
1 1 Clicked
2 2 Clicked
3 3 Viewed
5 5 Ignored
1 7 Ignored
2 7 Viewed
3 5 Clicked
1 4 Viewed
2 11 Viewed
1 2 Clicked
Output:
ad_id ctr
1 66.67
3 50
2 33.33
5 0
Explanation:
for ad_id = 1, ctr = (2/(2+1)) * 100 = 66.67
for ad_id = 2, ctr = (1/(1+2)) * 100 = 33.33
for ad_id = 3, ctr = (1/(1+1)) * 100 = 50.00
for ad_id = 5, ctr = 0.00, Note that ad_id = 5 has no clicks or views.
Note that we do not care about Ignored Ads.
ans ==
SELECT e.employee_id, t.team_size
FROM Employee e
JOIN (
  SELECT team_id, COUNT(*) AS team_size
  FROM Employee
  GROUP BY team_id
) t ON e.team_id = t.team_id



Q21.
Table: Employee
Column Name Type
employee_id int
team_id int
employee_id is the primary key for this table.
Each row of this table contains the ID of each employee and their respective team.
Write an SQL query to find the team size of each of the employees.
Return result table in any order.
The query result format is in the following example.
Input:
Employee Table:
employee_id team_id
1 8
2 8
3 8
4 7
5 9
6 9
Output:
employee_id team_size
1 3
2 3
3 3
4 1
5 2
6 2
Explanation:
Employees with Id 1,2,3 are part of a team with team_id = 8.
An employee with Id 4 is part of a team with team_id = 7.
Employees with Id 5,6 are part of a team with team_id = 9.
ans == 
SELECT e.employee_id, t.team_size
FROM Employee e
JOIN (
  SELECT team_id, COUNT(*) AS team_size
  FROM Employee
  GROUP BY team_id
) t ON e.team_id = t.team_id


Q22.
Table: Countries
Column Name Type
country_id int
country_name varchar
country_id is the primary key for this table.
Each row of this table contains the ID and the name of one country.
Table: Weather
Column Name Type
country_id int
weather_state int
day date
(country_id, day) is the primary key for this table.
Each row of this table indicates the weather state in a country for one day.
Write an SQL query to find the type of weather in each country for November 2019.
The type of weather is:
● Cold if the average weather_state is less than or equal 15,
● Hot if the average weather_state is greater than or equal to 25, and
● Warm otherwise.
Return result table in any order.
The query result format is in the following example.
Input:
Countries table:
country_id country_name
2 USA
3 Australia
7 Peru
5 China
8 Morocco
9 Spain
Weather table:
country_id weather_state day
2 15 2019-11-01
2 12 2019-10-28
2 12 2019-10-27
3 -2 2019-11-10
3 0 2019-11-11
3 3 2019-11-12
5 16 2019-11-07
5 18 2019-11-09
5 21 2019-11-23
7 25 2019-11-28
7 22 2019-12-01
7 20 2019-12-02
8 25 2019-11-05
8 27 2019-11-15
8 31 2019-11-25
9 7 2019-10-23
9 3 2019-12-23
Output:
country_name weather_type
USA Cold
Australia Cold
Peru Hot
Morocco Hot
China Warm
Explanation:
Average weather_state in the USA in November is (15) / 1 = 15 so the weather type is Cold.
Average weather_state in Australia in November is (-2 + 0 + 3) / 3 = 0.333 so the weather type is Cold.
Average weather_state in Peru in November is (25) / 1 = 25 so the weather type is Hot.
The average weather_state in China in November is (16 + 18 + 21) / 3 = 18.333 so the weather type is
warm.
Average weather_state in Morocco in November is (25 + 27 + 31) / 3 = 27.667 so the weather type is
Hot.
We know nothing about the average weather_state in Spain in November so we do not include it in the
result table.
ans=SELECT c.country_name,
    CASE
        WHEN AVG(w.weather_state) < 15 THEN 'Cold'
        WHEN AVG(w.weather_state) >= 25 THEN 'Hot'
        ELSE 'Warm'
    END AS weather_type
FROM Countries c
JOIN Weather w ON c.country_id = w.country_id
WHERE w.day >= '2019-11-01' AND w.day < '2019-12-01'
GROUP BY c.country_name
Explanation:

We join the Countries and Weather tables on country_id.
We filter the data by selecting only the weather records for November 2019.
We use the AVG function to calculate the average weather_state for each country.
We use a CASE statement to determine the weather type based on the average weather_state.
Finally, we group the results by country_name.




Q23.
Table: Prices
Column Name Type
product_id int
start_date date
end_date date
price int
(product_id, start_date, end_date) is the primary key for this table.
Each row of this table indicates the price of the product_id in the period from start_date to end_date.
For each product_id there will be no two overlapping periods. That means there will be no two
intersecting periods for the same product_id.
Table: UnitsSold
Column Name Type
product_id int
purchase_date date
units int
There is no primary key for this table, it may contain duplicates.
Each row of this table indicates the date, units, and product_id of each product sold.
Write an SQL query to find the average selling price for each product. average_price should be
rounded to 2 decimal places.
Return the result table in any order.
The query result format is in the following example.
Input:
Prices table:
product_id start_date end_date price
1 2019-02-17 2019-02-28 5
1 2019-03-01 2019-03-22 20
2 2019-02-01 2019-02-20 15
2 2019-02-21 2019-03-31 30
UnitsSold table:
product_id purchase_date units
1 2019-02-25 100
1 2019-03-01 15
2 2019-02-10 200
2 2019-03-22 30
Output:
product_id average_price
1 6.96
2 16.96
Explanation:
Average selling price = Total Price of Product / Number of products sold.
Average selling price for product 1 = ((100 * 5) + (15 * 20)) / 115 = 6.96
Average selling price for product 2 = ((200 * 15) + (30 * 30)) / 230 = 16.96
ans ==  SELECT ps.product_id, ROUND(SUM(ps.price * us.units) / SUM(us.units), 2) AS average_price
FROM Prices ps
INNER JOIN UnitsSold us
ON ps.product_id = us.product_id AND us.purchase_date >= ps.start_date AND us.purchase_date <= ps.end_date
GROUP BY ps.product_id;
Explanation:

We start by joining the Prices table with the UnitsSold table using the product_id column.
Then, we filter the rows of the UnitsSold table by selecting only those where the purchase_date falls within the period defined by the start_date and end_date columns of the Prices table. This is done by adding the condition us.purchase_date >= ps.start_date AND us.purchase_date <= ps.end_date to the ON clause of the JOIN.
Next, we group the resulting rows by the product_id column using the GROUP BY clause.
Finally, we calculate the average selling price for each product by summing the product of the price and units columns and dividing by the total number of units sold. The ROUND function is used to round the result to 2 decimal places.


Q24.
Table: Activity
Column Name Type
player_id int
device_id int
event_date date
games_played int
(player_id, event_date) is the primary key of this table.
This table shows the activity of players of some games.
Each row is a record of a player who logged in and played a number of games (possibly 0) before
logging out on someday using some device.
Write an SQL query to report the first login date for each player.
Return the result table in any order.
The query result format is in the following example.
Input:
Activity table:
player_id device_id event_date games_played
1 2 2016-03-01 5
1 2 2016-05-02 6
2 3 2017-06-25 1
3 1 2016-03-02 0
3 4 2018-07-03 5
Output:
player_id first_login
1 2016-03-01
2 2017-06-25
3 2016-03-02

ans==
SELECT 
  player_id, 
  MIN(event_date) as first_login 
FROM 
  Activity 
GROUP BY 
  player_id




Q25.
Table: Activity
Column Name Type
player_id int
device_id int
event_date date
games_played int
(player_id, event_date) is the primary key of this table.
This table shows the activity of players of some games.
Each row is a record of a player who logged in and played a number of games (possibly 0) before
logging out on someday using some device.
Write an SQL query to report the device that is first logged in for each player.
Return the result table in any order.
The query result format is in the following example.
Input:
Activity table:
player_id device_id event_date games_played
1 2 2016-03-01 5
1 2 2016-05-02 6
2 3 2017-06-25 1
3 1 2016-03-02 0
3 4 2018-07-03 5
Output:
player_id device_id
1 2
2 3
3 1


ans== SELECT 
  player_id, 
  FIRST_VALUE(device_id) OVER (PARTITION BY player_id ORDER BY event_date) as device_id 
FROM 
  Activity



Q26.
Table: Products
Column Name Type
product_id int
product_name varchar
product_category varchar
product_id is the primary key for this table.
This table contains data about the company's products.
Table: Orders
Column Name Type
product_id int
order_date date
unit int
There is no primary key for this table. It may have duplicate rows.
product_id is a foreign key to the Products table.
unit is the number of products ordered in order_date.
Write an SQL query to get the names of products that have at least 100 units ordered in February 2020
and their amount.
Return result table in any order.
The query result format is in the following example.
Input:
Products table:
product_id product_name
product_catego
ry
1
Leetcode
Solutions Book
2
Jewels of
Stringology Book
3 HP Laptop
4 Lenovo Laptop
5 Leetcode Kit T-shirt
Orders table:
product_id order_date unit
1 2020-02-05 60
1 2020-02-10 70
2 2020-01-18 30
2 2020-02-11 80
3 2020-02-17 2
3 2020-02-24 3
4 2020-03-01 20
4 2020-03-04 30
4 2020-03-04 60
5 2020-02-25 50
5 2020-02-27 50
5 2020-03-01 50
Output:
product_name unit
Leetcode Solutions 130
Leetcode Kit 100
Explanation:
Products with product_id = 1 is ordered in February a total of (60 + 70) = 130.
Products with product_id = 2 is ordered in February a total of 80.
Products with product_id = 3 is ordered in February a total of (2 + 3) = 5.
Products with product_id = 4 was not ordered in February 2020.
Products with product_id = 5 is ordered in February a total of (50 + 50) = 100.
Q27.
Table: Users
Column Name Type
user_id int
name varchar
mail varchar
user_id is the primary key for this table.
This table contains information of the users signed up in a website. Some emails are invalid.
Write an SQL query to find the users who have valid emails.
A valid e-mail has a prefix name and a domain where:
● The prefix name is a string that may contain letters (upper or lower case), digits, underscore
'_', period '.', and/or dash '-'. The prefix name must start with a letter.
● The domain is '@leetcode.com'.
Return the result table in any order.
The query result format is in the following example.
Input:
Users table:
user_id name mail
1 Winston
winston@leetc
ode.com
2 Jonathan jonathanisgreat
3 Annabelle
bella-@leetcod
e.com
4 Sally
sally.come@lee
tcode.com
5 Marwan
quarz#2020@le
etcode.com
6 David
david69@gmail
.com
7 Shapiro
.shapo@leetco
de.com
Output:
user_id name mail
1 Winston
winston@leetc
ode.com
3 Annabelle
bella-@leetcod
e.com
4 Sally
sally.come@lee
tcode.com
Explanation:
The mail of user 2 does not have a domain.
The mail of user 5 has the # sign which is not allowed.
The mail of user 6 does not have the leetcode domain.
The mail of user 7 starts with a period.
Q28.
Table: Customers
Column Name Type
customer_id int
name varchar
country varchar
customer_id is the primary key for this table.
This table contains information about the customers in the company.
Table: Product
Column Name Type
customer_id int
name varchar
country varchar
product_id is the primary key for this table.
This table contains information on the products in the company.
price is the product cost.
Table: Orders
Column Name Type
order_id int
customer_id int
product_id int
order_date date
quantity int
order_id is the primary key for this table.
This table contains information on customer orders.
customer_id is the id of the customer who bought "quantity" products with id "product_id".
Order_date is the date in format ('YYYY-MM-DD') when the order was shipped.
Write an SQL query to report the customer_id and customer_name of customers who have spent at
least $100 in each month of June and July 2020.
Return the result table in any order.
The query result format is in the following example.
Input:
Customers table:
customer_id name country
1 Winston USA
2 Jonathan Peru
3 Moustafa Egypt
Product table:
product_id description price
10 LC Phone 300
20 LC T-Shirt 10
30 LC Book 45
40 LC Keychain 2
Orders table:
order_id customer_id product_id order_date quantity
1 1 10 2020-06-10 1
2 1 20 2020-07-01 1
3 1 30 2020-07-08 2
4 2 10 2020-06-15 2
5 2 40 2020-07-01 10
6 3 20 2020-06-24 2
7 3 30 2020-06-25 2
9 3 30 2020-05-08 3
Output:
customer_id name
1 Winston
Explanation:
Winston spent $300 (300 * 1) in June and $100 ( 10 * 1 + 45 * 2) in July 2020.
Jonathan spent $600 (300 * 2) in June and $20 ( 2 * 10) in July 2020.
Moustafa spent $110 (10 * 2 + 45 * 2) in June and $0 in July 2020.
Q29.
Table: TVProgram
Column Name Type
program_date date
content_id int
channel varchar
(program_date, content_id) is the primary key for this table.
This table contains information about the programs on the TV.
content_id is the id of the program in some channel on the TV.
Table: Content
Column Name Type
content_id varchar
title varchar
Kids_content enum
content_type varchar
content_id is the primary key for this table.
Kids_content is an enum that takes one of the values ('Y', 'N') where:
'Y' means content for kids, otherwise 'N' is not content for kids.
content_type is the category of the content as movies, series, etc.
Write an SQL query to report the distinct titles of the kid-friendly movies streamed in June 2020.
Return the result table in any order.
The query result format is in the following example.
Input:
TVProgram table:
program_date content_id channel
2020-06-10 08:00 1 LC-Channel
2020-05-11 12:00 2 LC-Channel
2020-05-12 12:00 3 LC-Channel
2020-05-13 14:00 4 Disney Ch
2020-06-18 14:00 4 Disney Ch
2020-07-15 16:00 5 Disney Ch
Content table:
content_id title Kids_content content_type
1 Leetcode Movie N Movies
2 Alg. for Kids Y Series
3 Database Sols N Series
4 Aladdin Y Movies
5 Cinderella Y Movies
Output:
title
Aladdin
Explanation:
"Leetcode Movie" is not a content for kids.
"Alg. for Kids" is not a movie.
"Database Sols" is not a movie
"Alladin" is a movie, content for kids and was streamed in June 2020.
"Cinderella" was not streamed in June 2020.
Q30.
Table: NPV
Column Name Type
id int
year int
npv int
(id, year) is the primary key of this table.
The table has information about the id and the year of each inventory and the corresponding net
present value.
Table: Queries
Column Name Type
id int
year int
(id, year) is the primary key of this table.
The table has information about the id and the year of each inventory query.
Write an SQL query to find the npv of each query of the Queries table.
Return the result table in any order.
The query result format is in the following example.
Input:
NPV table:
id year npv
1 2018 100
7 2020 30
13 2019 40
1 2019 113
2 2008 121
3 2009 12
11 2020 99
7 2019 0
Queries table:
id year
1 2019
2 2008
3 2009
7 2018
7 2019
7 2020
13 2019
Output:
id year npv
1 2019 113
2 2008 121
3 2009 12
7 2018 0
7 2019 0
7 2020 30
13 2019 40
Explanation:
The npv value of (7, 2018) is not present in the NPV table, we consider it 0.
The npv values of all other queries can be found in the NPV table.
ans==
SELECT q.id, q.year, COALESCE(n.npv, 0) as npv
FROM Queries q
LEFT JOIN NPV n
ON q.id = n.id AND q.year = n.year
ORDER BY q.id, q.year;
Explanation:

We perform a LEFT JOIN between the Queries table and the NPV table on the id and year columns.
We use COALESCE to return 0 when there is no corresponding npv value in the NPV table for a given query.
We select the id, year, and npv columns from the resulting table.
We order the resulting table by id and year.


Q31.
Table: NPV
Column Name Type
id int
year int
npv int
(id, year) is the primary key of this table.
The table has information about the id and the year of each inventory and the corresponding net
present value.
Table: Queries
Column Name Type
id int
year int
(id, year) is the primary key of this table.
The table has information about the id and the year of each inventory query.
Write an SQL query to find the npv of each query of the Queries table.
Return the result table in any order.
The query result format is in the following example.
Input:
NPV table:
id year npv
1 2018 100
7 2020 30
13 2019 40
1 2019 113
2 2008 121
3 2009 12
11 2020 99
7 2019 0
Queries table:
id year
1 2019
2 2008
3 2009
7 2018
7 2019
7 2020
13 2019
Output:
id year npv
1 2019 113
2 2008 121
3 2009 12
7 2018 0
7 2019 0
7 2020 30
13 2019 40
Explanation:
The npv value of (7, 2018) is not present in the NPV table, we consider it 0.
The npv values of all other queries can be found in the NPV table.
ans== 
SELECT q.id, q.year, COALESCE(n.npv, 0) AS npv
FROM Queries q LEFT JOIN NPV n
ON q.id = n.id AND q.year = n.year
ORDER BY q.id, q.year ASC;
Explanation:
We perform a LEFT JOIN between the Queries table and the NPV table on the id and year columns. This will include all rows from the Queries table and matching rows from the NPV table. If a query does not have a corresponding npv value in the NPV table, then the npv value will be NULL. We use the COALESCE function to replace any NULL npv values with 0. We then select the id, year, and npv columns from the resulting table and order by the id and year columns in ascending order.


Q32.
Table: Employees
Column Name Type
id int
name varchar
id is the primary key for this table.
Each row of this table contains the id and the name of an employee in a company.
Table: EmployeeUNI
Column Name Type
id int
unique_id int
(id, unique_id) is the primary key for this table.
Each row of this table contains the id and the corresponding unique id of an employee in the
company.
Write an SQL query to show the unique ID of each user, If a user does not have a unique ID replace just
show null.
Return the result table in any order.
The query result format is in the following example.
Input:
Employees table:
id name
1 Alice
7 Bob
11 Meir
90 Winston
3 Jonathan
EmployeeUNI table:
id unique_id
3 1
11 2
90 3
Output:
unique_id name
null Alice
null Bob
2 Meir
3 Winston
1 Jonathan
Explanation:
Alice and Bob do not have a unique ID, We will show null instead.
The unique ID of Meir is 2.
The unique ID of Winston is 3.
The unique ID of Jonathan is 1.
ans=== SELECT e.name, eu.unique_id
FROM Employees e LEFT JOIN EmployeeUNI eu
ON e.id = eu.id
ORDER BY e.id ASC;
Explanation:
We perform a LEFT JOIN between the Employees table and EmployeeUNI table on the id column. This will include all rows from the Employees table and matching rows from the EmployeeUNI table. If an employee does not have a corresponding unique_id in the EmployeeUNI table, then the unique_id will be NULL. We then select the name and unique_id columns from the resulting table and order by the id column in ascending order.







Q33.
Table: Users
Column Name Type
id int
name varchar
id is the primary key for this table.
name is the name of the user.
Table: Rides
Column Name Type
id int
user_id int
distance int
id is the primary key for this table.
user_id is the id of the user who travelled the distance "distance".
Write an SQL query to report the distance travelled by each user.
Return the result table ordered by travelled_distance in descending order, if two or more users
travelled the same distance, order them by their name in ascending order.
The query result format is in the following example.
Input:
Users table:
id name
1 Alice
2 Bob
3 Alex
4 Donald
7 Lee
13 Jonathan
19 Elvis
Rides table:
id user_id distance
1 1 120
2 2 317
3 3 222
4 7 100
5 13 312
6 19 50
7 7 120
8 19 400
9 7 230
Output:
name
travelled_distan
ce
Elvis 450
Lee 450
Bob 317
Jonathan 312
Alex 222
Alice 120
Donald 0
Explanation:
Elvis and Lee travelled 450 miles, Elvis is the top traveller as his name is alphabetically smaller than
Lee.
Bob, Jonathan, Alex, and Alice have only one ride and we just order them by the total distances of the
ride.
Donald did not have any rides, the distance travelled by him is 0.
ans== 
SELECT u.name AS name, COALESCE(SUM(r.distance), 0) AS travelled_distance
FROM Users u
LEFT JOIN Rides r ON u.id = r.user_id
GROUP BY u.id
ORDER BY travelled_distance DESC, name ASC;



Q34.
Table: Products
Column Name Type
product_id int
product_name varchar
product_category varchar
product_id is the primary key for this table.
This table contains data about the company's products.
Table: Orders
Column Name Type
product_id int
order_date date
unit int
There is no primary key for this table. It may have duplicate rows.
product_id is a foreign key to the Products table.
unit is the number of products ordered in order_date.
Write an SQL query to get the names of products that have at least 100 units ordered in February 2020
and their amount.
Return result table in any order.
The query result format is in the following example.
Input:
Products table:
product_id product_name
product_catego
ry
1
Leetcode
Solutions Book
2
Jewels of
Stringology Book
3 HP Laptop
4 Lenovo Laptop
5 Leetcode Kit T-shirt
ans== SELECT p.product_name AS product_name, SUM(o.unit) AS amount
FROM Products p
INNER JOIN Orders o ON p.product_id = o.product_id
WHERE o.order_date >= '2020-02-01' AND o.order_date < '2020-03-01'
GROUP BY p.product_id
HAVING SUM(o.unit) >= 100;



Q35.
Table: Movies
Column Name Type
movie_id int
title varchar
movie_id is the primary key for this table.
The title is the name of the movie.
Table: Users
Column Name Type
user_id int
name varchar
user_id is the primary key for this table.
Table: MovieRating
Column Name Type
movie_id int
user_id int
rating int
created_at date
(movie_id, user_id) is the primary key for this table.
This table contains the rating of a movie by a user in their review.
created_at is the user's review date.
Write an SQL query to:
● Find the name of the user who has rated the greatest number of movies. In case of a tie,
return the lexicographically smaller user name.
● Find the movie name with the highest average rating in February 2020. In case of a tie, return
the lexicographically smaller movie name.
The query result format is in the following example.
Input:
Movies table:
movie_id title
1 Avengers
2 Frozen 2
3 Joker
Users table:
user_id name
1 Daniel
2 Monica
3 Maria
4 James
MovieRating table:
movie_id user_id rating created_at
1 1 3 2020-01-12
1 2 4 2020-02-11
1 3 2 2020-02-12
1 4 1 2020-01-01
2 1 5 2020-02-17
2 2 2 2020-02-01
2 3 2 2020-03-01
3 1 3 2020-02-22
3 2 4 2020-02-25
Output:
results
Daniel
Frozen 2
Explanation:
Daniel and Monica have rated 3 movies ("Avengers", "Frozen 2" and "Joker") but Daniel is smaller
lexicographically.
Frozen 2 and Joker have a rating average of 3.5 in February but Frozen 2 is smaller lexicographically.
ans== To find the name of the user who has rated the greatest number of movies, we can join the Users table with the MovieRating table, group by the user_id, and count the number of movies rated by each user. Then, we can order the result by the count in descending order and return the name of the user with the highest count.

To find the movie name with the highest average rating in February 2020, we can join the Movies table with the MovieRating table, filter the ratings for February 2020, group by the movie_id, and calculate the average rating for each movie. Then, we can order the result by the average rating in descending order and return the name of the movie with the highest average rating.

Here's the SQL query:

vbnet
Copy code
SELECT u.name AS results
FROM Users u
JOIN MovieRating mr ON u.user_id = mr.user_id
GROUP BY u.user_id
ORDER BY COUNT(DISTINCT mr.movie_id) DESC, u.name ASC
LIMIT 1;

SELECT m.title AS results
FROM Movies m
JOIN MovieRating mr ON m.movie_id = mr.movie_id
WHERE mr.created_at >= '2020-02-01' AND mr.created_at < '2020-03-01'
GROUP BY m.movie_id
ORDER BY AVG(mr.rating) DESC, m.title ASC
LIMIT 1;



Q36.
Table: Users
Column Name Type
id int
name varchar
id is the primary key for this table.
name is the name of the user.
Table: Rides
Column Name Type
id int
user_id int
distance int
id is the primary key for this table.
user_id is the id of the user who travelled the distance "distance".
Write an SQL query to report the distance travelled by each user.
Return the result table ordered by travelled_distance in descending order, if two or more users
travelled the same distance, order them by their name in ascending order.
The query result format is in the following example.
Input:
Users table:
id name
1 Alice
2 Bob
3 Alex
4 Donald
7 Lee
13 Jonathan
19 Elvis
Rides table:
id user_id distance
1 1 120
2 2 317
3 3 222
4 7 100
5 13 312
6 19 50
7 7 120
8 19 400
9 7 230
Output:
name
travelled_distan
ce
Elvis 450
Lee 450
Bob 317
Jonathan 312
Alex 222
Alice 120
Donald 0
Explanation:
Elvis and Lee travelled 450 miles, Elvis is the top traveller as his name is alphabetically smaller than
Lee.
Bob, Jonathan, Alex, and Alice have only one ride and we just order them by the total distances of the
ride.
Donald did not have any rides, the distance travelled by him is 0.
ans==
SELECT u.name AS name, COALESCE(SUM(r.distance), 0) AS travelled_distance
FROM Users u
LEFT JOIN Rides r ON u.id = r.user_id
GROUP BY u.id
ORDER BY travelled_distance DESC, name ASC;



Q37.
Table: Employees
Column Name Type
id int
name varchar
id is the primary key for this table.
Each row of this table contains the id and the name of an employee in a company.
Table: EmployeeUNI
Column Name Type
id int
unique_id int
(id, unique_id) is the primary key for this table.
Each row of this table contains the id and the corresponding unique id of an employee in the
company.
Write an SQL query to show the unique ID of each user, If a user does not have a unique ID replace just
show null.
Return the result table in any order.
The query result format is in the following example.
Input:
Employees table:
id name
1 Alice
7 Bob
11 Meir
90 Winston
3 Jonathan
EmployeeUNI table:
id unique_id
3 1
11 2
90 3
Output:
unique_id name
null Alice
null Bob
2 Meir
3 Winston
1 Jonathan
Explanation:
Alice and Bob do not have a unique ID, We will show null instead.
The unique ID of Meir is 2.
The unique ID of Winston is 3.
The unique ID of Jonathan is 1.
ans== 
SELECT EmployeeUNI.unique_id, Employees.name
FROM Employees 
LEFT JOIN EmployeeUNI 
ON Employees.id = EmployeeUNI.id;
In this query, we use a LEFT JOIN to combine the Employees and EmployeeUNI tables based on the id column. This ensures that all rows from the Employees table are included in the result, regardless of whether or not there is a matching row in the EmployeeUNI table. If a user does not have a unique ID, the corresponding unique_id value will be NULL.





Q38.
Table: Departments
Column Name Type
id int
name varchar
id is the primary key of this table.
The table has information about the id of each department of a university.
Table: Students
Column Name Type
id int
name varchar
department_id int
id is the primary key of this table.
The table has information about the id of each student at a university and the id of the department
he/she studies at.
Write an SQL query to find the id and the name of all students who are enrolled in departments that no
longer exist.
Return the result table in any order.
The query result format is in the following example.
Input:
Departments table:
id name
1 Electrical Engineering
7 Computer Engineering
13 Business Administration
Students table:
id name department_id
23 Alice 1
1 Bob 7
5 Jennifer 13
2 John 14
4 Jasmine 77
3 Steve 74
6 Luis 1
8 Jonathan 7
7 Daiana 33
11 Madelynn 1
Output:
id name
2 John
7 Daiana
4 Jasmine
3 Steve
Explanation:
John, Daiana, Steve, and Jasmine are enrolled in departments 14, 33, 74, and 77 respectively.
Department 14, 33, 74, and 77 do not exist in the Departments table.
ans== SELECT id, name
FROM Students
WHERE department_id NOT IN (SELECT id FROM Departments);
Explanation:
This query uses a subquery to select all the department ids that do not exist in the Departments table and then uses the NOT IN operator to select all the students who are enrolled in those departments. The result is a table with the id and name of all such students.


Q39.
Table: Calls
Column Name Type
from_id int
to_id int
duration int
This table does not have a primary key, it may contain duplicates.
This table contains the duration of a phone call between from_id and to_id.
from_id != to_id
Write an SQL query to report the number of calls and the total call duration between each pair of
distinct persons (person1, person2) where person1 < person2.
Return the result table in any order.
The query result format is in the following example.
Input:
Calls table:
from_id to_id duration
1 2 59
2 1 11
1 3 20
3 4 100
3 4 200
3 4 200
4 3 499
Output:
person1 person2 call_count total_duration
1 2 2 70
1 3 1 20
3 4 4 999
Explanation:
Users 1 and 2 had 2 calls and the total duration is 70 (59 + 11).
Users 1 and 3 had 1 call and the total duration is 20.
Users 3 and 4 had 4 calls and the total duration is 999 (100 + 200 + 200 + 499).
Q40.
Table: Prices
Column Name Type
product_id int
start_date date
end_date date
price int
(product_id, start_date, end_date) is the primary key for this table.
Each row of this table indicates the price of the product_id in the period from start_date to end_date.
For each product_id there will be no two overlapping periods. That means there will be no two
intersecting periods for the same product_id.
Table: UnitsSold
Column Name Type
product_id int
purchase_date date
units int
There is no primary key for this table, it may contain duplicates.
Each row of this table indicates the date, units, and product_id of each product sold.
Write an SQL query to find the average selling price for each product. average_price should be
rounded to 2 decimal places.
Return the result table in any order.
The query result format is in the following example.
Input:
Prices table:
product_id start_date end_date price
1 2019-02-17 2019-02-28 5
1 2019-03-01 2019-03-22 20
2 2019-02-01 2019-02-20 15
2 2019-02-21 2019-03-31 30
UnitsSold table:
product_id purchase_date units
1 2019-02-25 100
1 2019-03-01 15
2 2019-02-10 200
2 2019-03-22 30
Output:
product_id average_price
1 6.96
2 16.96
Explanation:
Average selling price = Total Price of Product / Number of products sold.
Average selling price for product 1 = ((100 * 5) + (15 * 20)) / 115 = 6.96
Average selling price for product 2 = ((200 * 15) + (30 * 30)) / 230 = 16.96
ans == SELECT
  UnitsSold.product_id,
  ROUND(SUM(UnitsSold.units * Prices.price) / SUM(UnitsSold.units), 2) AS average_price
FROM
  UnitsSold
  JOIN Prices ON UnitsSold.product_id = Prices.product_id
  AND UnitsSold.purchase_date BETWEEN Prices.start_date AND Prices.end_date
GROUP BY
  UnitsSold.product_id
Explanation:

We join the UnitsSold and Prices tables on the product_id and check if the purchase_date falls within the start_date and end_date of the Prices table.
We then calculate the total price of the product by multiplying the number of units sold with the price, and sum this over all purchases.
We also sum the total number of units sold for the product.
Finally, we calculate the average selling price by dividing the total price by the total number of units sold and rounding it to 2 decimal places.



Q41.
Table: Warehouse
Column Name Type
name varchar
product_id int
units int
(name, product_id) is the primary key for this table.
Each row of this table contains the information of the products in each warehouse.
Table: Products
Column Name Type
product_id int
product_name varchar
Width int
Length int
Height int
product_id is the primary key for this table.
Each row of this table contains information about the product dimensions (Width, Length, and Height)
in feets of each product.
Write an SQL query to report the number of cubic feet of volume the inventory occupies in each
warehouse.
Return the result table in any order.
The query result format is in the following example.
Input:
Warehouse table:
name product_id units
LCHouse1 1 1
LCHouse1 2 10
LCHouse1 3 5
LCHouse2 1 2
LCHouse2 2 2
LCHouse3 4 1
Products table:
product_id product_name Width Length Height
1 LC-TV 5 50 40
2 LC-KeyChain 5 5 5
3 LC-Phone 2 10 10
4 LC-T-Shirt 4 10 20
Output:
warehouse_name volume
LCHouse1 12250
LCHouse2 20250
LCHouse3 800
ans===
SELECT w.name AS warehouse_name, SUM(p.Width * p.Length * p.Height * w.units) AS volume
FROM Warehouse w
JOIN Products p ON w.product_id = p.product_id
GROUP BY w.name;
Explanation:

We select the warehouse name as warehouse_name and the computed volume as volume.
We join the Warehouse table with the Products table on the product_id column.
We compute the volume as the product of the three dimensions (Width x Length x Height) multiplied by the number of units, using the SUM aggregation function to add up the volumes for each product in the warehouse.
We group the result by the warehouse name using the GROUP BY clause.




Q42.
Table: Sales
Column Name Type
sale_date date
fruit enum
sold_num int
(sale_date, fruit) is the primary key for this table.
This table contains the sales of "apples" and "oranges" sold each day.
Write an SQL query to report the difference between the number of apples and oranges sold each day.
Return the result table ordered by sale_date.
The query result format is in the following example.
Input:
Sales table:
sale_date fruit sold_num
2020-05-01 apples 10
2020-05-01 oranges 8
2020-05-02 apples 15
2020-05-02 oranges 15
2020-05-03 apples 20
2020-05-03 oranges 0
2020-05-04 apples 15
2020-05-04 oranges 16
Output:
sale_date diff
2020-05-01 2
2020-05-02 0
2020-05-03 20
2020-05-04 -1
Explanation:
Day 2020-05-01, 10 apples and 8 oranges were sold (Difference 10 - 8 = 2).
Day 2020-05-02, 15 apples and 15 oranges were sold (Difference 15 - 15 = 0).
Day 2020-05-03, 20 apples and 0 oranges were sold (Difference 20 - 0 = 20).
Day 2020-05-04, 15 apples and 16 oranges were sold (Difference 15 - 16 = -1).


ans == SELECT a.sale_date, a.apple_sales - b.orange_sales as diff
FROM (
    SELECT sale_date, SUM(sold_num) as apple_sales
    FROM Sales
    WHERE fruit = 'apples'
    GROUP BY sale_date
) as a
JOIN (
    SELECT sale_date, SUM(sold_num) as orange_sales
    FROM Sales
    WHERE fruit = 'oranges'
    GROUP BY sale_date
) as b
ON a.sale_date = b.sale_date
ORDER BY a.sale_date
In the subqueries, we use the SUM() function to calculate the total sales of apples and oranges for each day. Then we join the subqueries on the sale_date column and compute the difference between the apple and orange sales.

The ORDER BY clause is used to sort the results by sale_date in ascending order.

Note that the enum data type used in the fruit column is specific to MySQL and not part of standard SQL. If you're using a different database system, you may need to use a different data type or change the query accordingly.






Q43.
Table: Activity
Column Name Type
player_id int
device_id int
event_date date
games_played int
(player_id, event_date) is the primary key of this table.
This table shows the activity of players of some games.
Each row is a record of a player who logged in and played a number of games (possibly 0) before
logging out on someday using some device.
Write an SQL query to report the fraction of players that logged in again on the day after the day they
first logged in, rounded to 2 decimal places. In other words, you need to count the number of players
that logged in for at least two consecutive days starting from their first login date, then divide that
number by the total number of players.
The query result format is in the following example.
Input:
Activity table:
player_id device_id event_date games_played
1 2 2016-03-01 5
1 2 2016-03-02 6
2 3 2017-06-25 1
3 1 2016-03-02 0
3 4 2018-07-03 5
Output:
fraction
0.33
Explanation:
Only the player with id 1 logged back in after the first day he had logged in so the answer is 1/3 = 0.33
ans==
WITH consecutive_logins AS (
    SELECT DISTINCT a1.player_id
    FROM Activity a1
    JOIN Activity a2 ON a1.player_id = a2.player_id
        AND a1.event_date = DATE_SUB(a2.event_date, INTERVAL 1 DAY)
)
SELECT ROUND(COUNT(DISTINCT consecutive_logins.player_id) / COUNT(DISTINCT Activity.player_id), 2) as fraction
FROM Activity
JOIN consecutive_logins ON Activity.player_id = consecutive_logins.player_id
Explanation:

First, we create a subquery consecutive_logins to find all players who have logged in for at least two consecutive days by joining the Activity table with itself and checking if there exists another login record with the same player_id and an event_date that is exactly one day earlier. 
We then select only the distinct player_id values from this join result.

Next, we join this consecutive_logins subquery with the Activity table on player_id to get all the login records of those players who have logged in for at least two consecutive days.
 We then divide the count of distinct player_id values from consecutive_logins by the count of distinct player_id values from Activity to get the fraction of players who logged in again on the day after the day they first logged in. We round the result to 2 decimal places using the ROUND function







Q44.
Table: Employee
Column Name Type
id int
name varchar
department varchar
managerId int
id is the primary key column for this table.
Each row of this table indicates the name of an employee, their department, and the id of their
manager.
If managerId is null, then the employee does not have a manager.
No employee will be the manager of themself.
Write an SQL query to report the managers with at least five direct reports.
Return the result table in any order.
The query result format is in the following example.
Input:
Employee table:
id name department managerId
101 John A None
102 Dan A 101
103 James A 101
104 Amy A 101
105 Anne A 101
106 Ron B 101
Output:
name
John
ans == WITH DirectReports AS (
  SELECT managerId, COUNT(*) AS numDirectReports
  FROM Employee
  WHERE managerId IS NOT NULL
  GROUP BY managerId
)
SELECT e.name
FROM Employee e
JOIN DirectReports d ON e.id = d.managerId
WHERE d.numDirectReports >= 5;
This query first creates a Common Table Expression (CTE) called "DirectReports" that counts the number of direct reports for each manager in the Employee table.
 It then joins the DirectReports CTE with the Employee table to select the names of the managers who have at least 5 direct reports.



Q45.
Table: Student
Column Name Type
student_id int
student_name varchar
gender varchar
dept_id int
student_id is the primary key column for this table.
dept_id is a foreign key to dept_id in the Department tables.
Each row of this table indicates the name of a student, their gender, and the id of their department.
Table: Department
Column Name Type
dept_id int
dept_name varchar
dept_id is the primary key column for this table.
Each row of this table contains the id and the name of a department.
Write an SQL query to report the respective department name and number of students majoring in
each department for all departments in the Department table (even ones with no current students).
Return the result table ordered by student_number in descending order. In case of a tie, order them by
dept_name alphabetically.
The query result format is in the following example.
Input:
Student table:
student_id student_name gender dept_id
1 Jack M 1
2 Jane F 1
3 Mark M 2
Department table:
dept_id dept_name
1 Engineering
2 Science
3 Law
Output:
dept_name
student_numbe
r
Engineering 2
Science 1
Law 0
ans== SELECT Department.dept_name, COUNT(Student.student_id) AS student_number
FROM Department
LEFT JOIN Student ON Department.dept_id = Student.dept_id
GROUP BY Department.dept_id
ORDER BY student_number DESC, Department.dept_name ASC;
Explanation:

We use a LEFT JOIN to join the Student and Department tables so that we include all departments, even those with no current students.
We count the number of students in each department using the COUNT function and alias it as student_number.
We group the results by the department id so that we can apply the COUNT function properly.
Finally, we order the results by student_number in descending order and by dept_name alphabetically.








Q46.
Table: Customer
Column Name Type
customer_id int
product_key int
There is no primary key for this table. It may contain duplicates.
product_key is a foreign key to the Product table.
Table: Product
Column Name Type
product_key int
product_key is the primary key column for this table.
Write an SQL query to report the customer ids from the Customer table that bought all the products in
the Product table.
Return the result table in any order.
The query result format is in the following example.
Input:
Customer table:
customer_id product_key
1 5
2 6
3 5
3 6
1 6
Product table:
product_key
5
6
Output:
customer_id
1
3
Explanation:
The customers who bought all the products (5 and 6) are customers with IDs 1 and 3.\
ans==
SELECT p.project_id, e.employee_id
FROM Project p
INNER JOIN Employee e ON p.employee_id = e.employee_id
WHERE (p.project_id, e.experience_years) IN (
    SELECT project_id, MAX(experience_years)
    FROM Project
    INNER JOIN Employee ON Project.employee_id = Employee.employee_id
    GROUP BY project_id
)
ORDER BY p.project_id;
Explanation:

The inner subquery selects the project_id and maximum experience_years for each project.
The outer query joins the Project and Employee tables and selects the project_id and employee_id where the project_id and experience_years match the values in the subquery.
The WHERE clause also filters out any rows where the employee has less experience than the maximum or where the project has no employees with at least that level of experience.
Finally, the results are sorted by project_id.




Q47.
Table: Project
Column Name Type
project_id int
employee_id int
(project_id, employee_id) is the primary key of this table.
employee_id is a foreign key to the Employee table.
Each row of this table indicates that the employee with employee_id is working on the project with
project_id.
Table: Employee
Column Name Type
employee_id int
name varchar
experience_yea
rs int
employee_id is the primary key of this table.
Each row of this table contains information about one employee.
Write an SQL query that reports the most experienced employees in each project. In case of a tie,
report all employees with the maximum number of experience years.
Return the result table in any order.
The query result format is in the following example.
Input:
Project table:
project_id employee_id
1 1
1 2
1 3
2 1
2 4
Employee table:
employee_id name
experience_yea
rs
1 Khaled 3
2 Ali 2
3 John 3
4 Doe 2
Output:
project_id employee_id
1 1
1 3
2 1
Explanation:
Both employees with id 1 and 3 have the most experience among the employees of the first project.
For the second project, the employee with id 1 has the most experience.
Q48.
Table: Books
Column Name Type
book_id int
name varchar
available_from date
book_id is the primary key of this table.
Table: Orders
Column Name Type
order_id int
book_id int
quantity int
dispatch_date date
order_id is the primary key of this table.
book_id is a foreign key to the Books table.
Write an SQL query that reports the books that have sold less than 10 copies in the last year,
excluding books that have been available for less than one month from today. Assume today is
2019-06-23.
Return the result table in any order.
The query result format is in the following example.
Input:
Books table:
book_id name available_from
1
"Kalila And
Demna" 2010-01-01
2 "28 Letters" 2012-05-12
3 "The Hobbit" 2019-06-10
4
"13 Reasons
Why" 2019-06-01
5
"The Hunger
Games" 2008-09-21
ans == 
FROM Books b
LEFT JOIN (
  SELECT book_id, SUM(quantity) AS total_sold
  FROM Orders
  WHERE dispatch_date BETWEEN DATE_SUB('2019-06-23', INTERVAL 1 YEAR) AND '2019-06-23'
  GROUP BY book_id
) o ON b.book_id = o.book_id
WHERE b.available_from <= DATE_SUB('2019-06-23', INTERVAL 1 MONTH)
  AND (o.total_sold IS NULL OR o.total_sold < 10)
Explanation:

First, we use a subquery to join the Orders table with the Books table to calculate the total number of copies sold for each book in the last year.
Then, we use a LEFT JOIN to include all books in the Books table, even if they haven't been sold in the last year.
We filter out books that have been available for less than one month from today using the WHERE clause.
Finally, we use a condition to select only books that have sold less than 10 copies in the last year or haven't been sold at all.



Q49.
Table: Enrollments
Column Name Type
student_id int
course_id int
grade int
(student_id, course_id) is the primary key of this table.
Write a SQL query to find the highest grade with its corresponding course for each student. In case of
a tie, you should find the course with the smallest course_id.
Return the result table ordered by student_id in ascending order.
The query result format is in the following example.
Input:
Enrollments table:
student_id course_id grade
2 2 95
2 3 95
1 1 90
1 2 99
3 1 80
3 2 75
3 3 82
Output:
student_id course_id grade
1 2 99
2 2 95
3 3 82

ans== 
SELECT b.book_id, b.name
FROM Books b
LEFT JOIN (
  SELECT book_id, SUM(quantity) AS total_quantity
  FROM Orders
  WHERE dispatch_date >= DATE_SUB('2019-06-23', INTERVAL 1 YEAR)
  GROUP BY book_id
  HAVING total_quantity < 10
) o ON b.book_id = o.book_id
WHERE b.available_from < DATE_SUB('2019-06-23', INTERVAL 1 MONTH)
AND o.book_id IS NULL;
Explanation:

The subquery calculates the total quantity of books sold in the last year for each book and filters out books with a total quantity greater than or equal to 10.
The outer query selects books that have been available for more than one month from today and have not been sold less than 10 copies in the last year. 
It uses a left join with the subquery, and selects books where the book_id from the subquery is NULL, meaning there were no orders for that book in the last year or the total quantity sold was greater than or equal to 10.

Q50.
Table: Teams
Column Name Type
team_id int
team_name varchar
team_id is the primary key of this table.
Each row of this table represents a single football team.
Table: Matches
Column Name Type
match_id int
host_team int
guest_team int
host_goals int
guest_goals int
match_id is the primary key of this table.
Each row is a record of a finished match between two different teams.
Teams host_team and guest_team are represented by their IDs in the Teams table (team_id), and they
scored host_goals and guest_goals goals, respectively.
The winner in each group is the player who scored the maximum total points within the group. In the
case of a tie, the lowest player_id wins.
Write an SQL query to find the winner in each group.
Return the result table in any order.
The query result format is in the following example.
Input:
Players table:
player_id group_id
15 1
25 1
30 1
45 1
10 2
35 2
50 2
20 3
40 3
Matches table:
match_id first_player second_player first_score second_score
1
1
5
4
5
3
0
2
3
0
2
5
1
2
3
3
0
1
5
2
0
4
4
0
2
0
5
2
5
3
5
5
0
1
1
O
u
t
p
u
t: group_id
pla
y
e
r
_id
1
1
5
2
3
5
3
4
0